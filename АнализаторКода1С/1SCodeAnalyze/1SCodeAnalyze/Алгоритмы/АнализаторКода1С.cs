using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Text.RegularExpressions;
using System.IO;

namespace _1SCodeAnalyze
{

/*
Функция ИнициализироватьРегулярноеВыражение(Паттерн)
	RegExp_=Новый COMОбъект("VBScript.RegExp");
	RegExp_.IgnoreCase = -1; //Игнорировать регистр
	RegExp_.Global = -1; //Поиск всех вхождений шаблона
	RegExp_.MultiLine = -1; //Многострочный режим
	RegExp_.Pattern = Паттерн;
	Возврат RegExp_;
КонецФункции

Функция ЭкранироватьРег(Знач Текст)
	Экранировать = "|.+*(){}^$[]?/";
	Текст = СтрЗаменить(Текст,"\","\\");
	Для н = 1 по СтрДлина(Экранировать) Цикл 
		Сим = Сред(Экранировать,н,1); 
		Текст = СтрЗаменить(Текст,Сим,"\"+Сим);
	КонецЦикла;
	Текст = СтрЗаменить(Текст," ","[\s]?");
	Возврат Текст;
КонецФункции

Функция ЭтоСистемнаяФункция(Текст)
	//Возврат Ложь;
	Системные = " формат( , сумма( , пустаястрока( , значениезаполнено( , запрос( , соответствие( , структура( , срезпоследних( , обороты( , ?( , типзнч( , тип( , сообщить( , количество( , окр( , строка( , сокрлп( , предупреждение( , заполнитьзначениясвойств( , и (  , сред( ,  лев( , прав( , число( , текущаядата( , максимум( , среднее( , минимум( , найти( , или ( ";	
	Возврат Найти(Системные,нрег(Текст))>0;
КонецФункции

Функция ЕстьЗапрос(Текст, Параметры)
	RegExp_ = ИнициализироватьРегулярноеВыражение("^(?!\/\/)[^\/]*?\.(выполнить|найтипокоду|найтипореквизиту|найтипонаименованию)[\s]?\("); //Находим незакомментированный запрос в коде
	Matches = RegExp_.Execute(Текст);
	ЧислоВхождений = Matches.Count();
	Если ЧислоВхождений = 0 Тогда Возврат Ложь; КонецЕсли;
	Параметры.Косяк = Matches.Item(0).Submatches.Item(0);
	Параметры.Смещение = Matches.Item(0).FirstIndex;
	Возврат Истина; 
КонецФункции

Функция НайденаПроцедураСЗапросом(ТекстБлока, Параметры, ИмяПроцедуры)
	Если ЕстьЗапрос(ТекстБлока, Параметры) Тогда
		Возврат Истина;
	КонецЕсли;
	Параметры.Вложенность = Параметры.Вложенность + 1;
	Если Параметры.Вложенность > 35 Тогда 
		Возврат Ложь; 
	КонецЕсли;//глубина стека вызовов 
	RegExp2 = ИнициализироватьРегулярноеВыражение("");   
	RegExp_ = ИнициализироватьРегулярноеВыражение("^(?!\/\/)[^\.\/]*?([а-яa-z0-9_]*?[\s]?\()"); //Поиск вызываемых в цикле методов, необходимо фильтровать закомментированные функции
	Matches = RegExp_.Execute(ТекстБлока);
	ЧислоВхождений = Matches.Count();
	Если ЧислоВхождений = 0 Тогда Возврат Ложь; КонецЕсли;
	Для к = 0 По ЧислоВхождений-1 Цикл
		ОбработкаПрерыванияПользователя();
		Match = Matches.Item(к);
		Value = Match.Submatches.Item(0);//берем лишь название метода с одной скобкой из группировки  без пробелов и точек
		Если Value = ИмяПроцедуры Тогда
		//Рекурсия 	
				Параметры.Косяк = "Рекурсия в функции "+value +")->" + Параметры.Косяк;
                Продолжить;
		КонецЕсли;
		
		Состояние(Value);
		Если ЭтоСистемнаяФункция(Value) Тогда Продолжить; КонецЕсли;
		
		RegExp2.Pattern = "(Процедур|Функци)[ая][\s]*?" + ЭкранироватьРег(Value) + "([\S\s]*?)Конец\1[ыи]";   // поиск тела найденной в цикле функции во всем тексте модуля
		Matches2 = RegExp2.Execute(Параметры.Текст);
		ЧислоВхождений2 = Matches2.Count();
		Если ЧислоВхождений2 <> 1 Тогда Продолжить; КонецЕсли;
		//сюда попадает тело найденой процедуры
		ТекстПроцедуры = Matches2.Item(0).SubMatches.Item(1); //без названия самой процедуры чтоб не впасть в ложную рекурсию
		Если НайденаПроцедураСЗапросом(ТекстПроцедуры, Параметры, Value) Тогда  //ищем в теле метода запросы или другие методы с запросами .. рекурсивно вызывая саму себя погружаясь все глубже в код
			Параметры.Косяк = value +")->" + Параметры.Косяк + "("+?(Параметры.Вложенность = 1,Строка(НайтиномерСтроки(Параметры,Параметры.Match.FirstIndex + Match.FirstIndex)),"") +")";
			Возврат Истина;
		КонецЕсли;
	КонецЦикла;
	Возврат Ложь;
КонецФункции

Функция НайтиЗапросВЦикле(Параметры)
	RegExp = ИнициализироватьРегулярноеВыражение("(Для|Пока).+Цикл[\S\s]*?КонецЦикла"); //(Для|Пока).+ нужен иначе выражение находит ....Цикла;   код код код для цикл   КонецЦикла;
	//  необходимо переработать это выражение т.к если попадаются вложенные циклы то обрабатываются неверно
	Matches = RegExp.Execute(Параметры.Текст);
	ЧислоВхождений=Matches.Count();
	Если ЧислоВхождений>0 Тогда 
		Для к = 0 По ЧислоВхождений-1 Цикл
			ОбработкаПрерыванияПользователя();
			Match = Matches.Item(к);
			Параметры.Match = Match;
			Параметры.Вложенность = 0;
			Параметры.Смещение = 0;
			Параметры.Косяк =" Цикл(";
			НомерСтроки = "("+Строка(НайтиномерСтроки(Параметры,Match.FirstIndex))+").";
			Если ЕстьЗапрос(Match.Value, Параметры) Тогда
				Параметры.Косяк = "Прямой запрос в цикле "+ НомерСтроки + Параметры.Косяк +"();";
				ДобавитьСтрокуВТаблицу(Параметры);
				Продолжить;
			ИначеЕсли НайденаПроцедураСЗапросом(Match.Value, Параметры, "") Тогда
				Параметры.Косяк =  НомерСтроки + Параметры.Косяк;
				ДобавитьСтрокуВТаблицу(Параметры);
				Продолжить;
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;	
КонецФункции

Функция _СтрЧислоВхождений(Текст, Подстрока)   //Количество вхождений не закомментированной подстроки 
	RegExp_ = ИнициализироватьРегулярноеВыражение("^(?!\/\/)[^\/]*?[^a-zа-я0-9_]"+ ЭкранироватьРег(Подстрока)+"[^a-zа-я0-9_]");
	Возврат RegExp_.Execute(Текст).Count();
КонецФункции

*/


    class АнализаторКода1С
    {
		String ИдентификаторЗапросов = "выполнить|найтипокоду|найтипореквизиту|найтипонаименованию";
		//String "(Процедур|Функци)[ая][\s]*?" + ЭкранироватьРег(Value) + "([\S\s]*?)Конец\1[ыи]"
			List<FileInfo> files;
		public АнализаторКода1С(List<FileInfo> files) {
            this.files = files;
          // List НайтиЗапросы("аорпорп");
        }

        private String СчитатьСодержимоеФайла(FileInfo file)
        {
            var Str = file.OpenText();
            return Str.ReadToEnd();
        }

		public void ОбойтиВсеФайлы(){
			foreach(FileInfo Файл in files){
				Console.WriteLine(Файл.FullName);
				НайтиВсеФункцииИПроцедуры(СчитатьСодержимоеФайла(Файл));
			}

		}

		public void НайтиВсеФункцииИПроцедуры(String ИсходныйКод){
			var ПоискФункций = new Regex(@"^(?!\/\/)[^\.\/]*?(procedur|functio|Процедур|Функци)[enая][\s]*?([А-Яа-яa-z0-9_]*?[\s]?\()([\S\s]*?)Конец\1[enыи]",RegexOptions.IgnoreCase|RegexOptions.Multiline);
			MatchCollection Найдены = ПоискФункций.Matches(ИсходныйКод);
			foreach(Match Функция in Найдены)
				foreach (Capture capture in Функция.Captures)
					{
						Console.WriteLine("Index={0}, Value={1}", capture.Index, capture.Value);
					}



		}


    }
}
