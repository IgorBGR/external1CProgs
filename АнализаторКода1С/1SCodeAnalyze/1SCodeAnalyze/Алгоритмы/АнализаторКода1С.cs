using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Text.RegularExpressions;
using System.IO;
using _1SCodeAnalyze.Структуры;

namespace _1SCodeAnalyze
{
    /*
Функция НайденаПроцедураСЗапросом(ТекстБлока, Параметры, ИмяПроцедуры)
    Если ЕстьЗапрос(ТекстБлока, Параметры) Тогда
        Возврат Истина;
    КонецЕсли;
    Параметры.Вложенность = Параметры.Вложенность + 1;
    Если Параметры.Вложенность > 35 Тогда 
        Возврат Ложь; 
    КонецЕсли;//глубина стека вызовов 
    RegExp2 = ИнициализироватьРегулярноеВыражение("");   
    RegExp_ = ИнициализироватьРегулярноеВыражение(@"^(?!\/\/)[^\.\/]*?([а-яa-z0-9_]*?[\s]?\()"); //Поиск вызываемых в цикле методов, необходимо фильтровать закомментированные функции
    Matches = RegExp_.Execute(ТекстБлока);
    ЧислоВхождений = Matches.Count();
    Если ЧислоВхождений = 0 Тогда Возврат Ложь; КонецЕсли;
    Для к = 0 По ЧислоВхождений-1 Цикл
        ОбработкаПрерыванияПользователя();
        Match = Matches.Item(к);
        Value = Match.Submatches.Item(0);//берем лишь название метода с одной скобкой из группировки  без пробелов и точек
        Если Value = ИмяПроцедуры Тогда
        //Рекурсия 	
                Параметры.Косяк = "Рекурсия в функции "+value +")->" + Параметры.Косяк;
                Продолжить;
        КонецЕсли;
		
        Состояние(Value);
        Если ЭтоСистемнаяФункция(Value) Тогда Продолжить; КонецЕсли;
		
        RegExp2.Pattern = @"(Процедур|Функци)[ая][\s]*?" + ЭкранироватьРег(Value) + "([\S\s]*?)Конец\1[ыи]";   // поиск тела найденной в цикле функции во всем тексте модуля
        Matches2 = RegExp2.Execute(Параметры.Текст);
        ЧислоВхождений2 = Matches2.Count();
        Если ЧислоВхождений2 <> 1 Тогда Продолжить; КонецЕсли;
        //сюда попадает тело найденой процедуры
        ТекстПроцедуры = Matches2.Item(0).SubMatches.Item(1); //без названия самой процедуры чтоб не впасть в ложную рекурсию
        Если НайденаПроцедураСЗапросом(ТекстПроцедуры, Параметры, Value) Тогда  //ищем в теле метода запросы или другие методы с запросами .. рекурсивно вызывая саму себя погружаясь все глубже в код
            Параметры.Косяк = value +")->" + Параметры.Косяк + "("+?(Параметры.Вложенность = 1,Строка(НайтиномерСтроки(Параметры,Параметры.Match.FirstIndex + Match.FirstIndex)),"") +")";
            Возврат Истина;
        КонецЕсли;
    КонецЦикла;
    Возврат Ложь;
КонецФункции
@"^(?!\/\/)[^\/]*?\.(выполнить|найтипокоду|найтипореквизиту|найтипонаименованию)[\s]?\(");
Функция _СтрЧислоВхождений(Текст, Подстрока)   //Количество вхождений не закомментированной подстроки 
    RegExp_ = ИнициализироватьРегулярноеВыражение("^(?!\/\/)[^\/]*?[^a-zа-я0-9_]"+ ЭкранироватьРег(Подстрока)+"[^a-zа-я0-9_]");
    Возврат RegExp_.Execute(Текст).Count();
КонецФункции

*/
    //String @"(Процедур|Функци)[ая][\s]*?" + ЭкранироватьРег(Value) + "([\S\s]*?)Конец\1[ыи]"	
    class АнализаторКода1С
    {

        Dictionary<String, Модуль> Модули;
        List<FileInfo> files;

        public АнализаторКода1С(List<FileInfo> files)
        {
            this.files = files;
            Модули = new Dictionary<string, Модуль>();
            ОбойтиВсеФайлы();

        }

        private void ОбойтиВсеФайлы()
        {
            foreach (FileInfo Файл in files)
            {
                String ИмяМодуля = Файл.Name.Replace(".Модуль.txt", "").Replace("ОбщийМодуль.", "").Replace(".txt", "");
                Модуль МодульОбъекта = new Модуль(Файл);
                if (!Модули.ContainsKey(ИмяМодуля))
                {
                    Модули.Add(ИмяМодуля, МодульОбъекта);
                }
            }

			//foreach (KeyValuePair<String, Модуль> Объект in Модули)НайтиВсеФункцииИПроцедуры(Объект.Value);
			foreach (KeyValuePair<String, Модуль> Объект in Модули)АнализироватьЦиклы(Объект.Value);
			foreach (KeyValuePair<String, Модуль> Объект in Модули)if(Объект.Value.ЕстьОшибки){
				Console.WriteLine("Модуль "+Объект.Key);
				foreach(var T in Объект.Value.ТаблицаАнализа){
					Console.WriteLine("->"+T.ОписаниеПроблемы);
				}
			}
			//var errors = from Модуль МодульОбъекта in Модули where МодульОбъекта.ЕстьЗапрос select МодульОбъекта.ТаблицаАнализа;


        }

		#region Методы поиска процедур и функций 
        private Boolean РекурсивныйПоискЗапроса(String Текст, Модуль МодульОбъекта, int Index,  СвойстваМетодов СвойствоМетода, String ВызывающийМетод)
        {
            ТелоКода Тело = new ТелоКода(Текст, МодульОбъекта, Index);
			if (Тело.ЕстьЗапрос()) {СвойствоМетода.ЕстьЗапрос = true; return true; }
            //Ищем другие вызываемые процедуры
            var ПоискВызовов = new Regex(@"^(?!\/\/)[^\.\/]*?([а-яa-z0-9_]*?)[\s]?\(", RegexOptions.IgnoreCase | RegexOptions.Multiline);
            MatchCollection Найдены = ПоискВызовов.Matches(Текст);
            foreach (Match Вызов in Найдены)
            {
				if(ВызывающийМетод.Contains(Вызов.Value))continue;//self call
                var ПоискМетода = new Regex(@"(Процедур|Функци|procedur|functio)[аяne][\s]*?" + ЭкранироватьРег(Вызов.Value) + @"[\s]*?\(([\S\s]*?)(Конец|end)\1[ыиen]", RegexOptions.IgnoreCase | RegexOptions.Multiline);
                Match Найден = ПоискМетода.Match(МодульОбъекта.Текст);
                if (!Найден.Success)
                    continue;
                //натравим на эти процедуры эту же функцию
				if(РекурсивныйПоискЗапроса(Найден.Groups[2].Value, МодульОбъекта, Найден.Index, СвойствоМетода, Вызов.Value)){ 
					СвойствоМетода.ЕстьЗапрос = true;
					СвойствоМетода.ДобавитьВызов(Вызов.Value); 
					return true;}
            }
            return false;
        }
        /// <summary>
        /// Фунция экранирует символы для нормальной подстановки в регулярное выражение
        /// </summary>
        /// <param name="s">Исходная строка</param>
        /// <returns>Результирующая строка</returns>
        private string ЭкранироватьРег(string s)
        {
            string p = s;
            foreach (char c in @"\|.+*(){}^$[]?/".ToCharArray())p = p.Replace("" + c, @"\" + c);
            return p.Replace(" ", @"[\s]*?");
        }

		/// <summary>
		/// Метод производит поиск всех всех функции И процедур.
		/// отмечая их свойства: с запросом и стек вызовов
		/// </summary>
		/// <param name="МодульОбъекта">Модуль объекта.</param>
		private void НайтиВсеФункцииИПроцедуры(Модуль МодульОбъекта)
        {
            var ПоискФункций = new Regex(@"^(?!\/\/)[^\.\/]*?(procedur|functio|Процедур|Функци)[enая][\s]*?([А-Яа-яa-z0-9_]*?)[\s]?\(([\S\s]*?)(Конец|End)\1[enыи]", RegexOptions.IgnoreCase | RegexOptions.Multiline);
			MatchCollection Найдены = ПоискФункций.Matches(МодульОбъекта.Текст);
            foreach (Match Функция in Найдены)
            {
				СвойстваМетодов СвойствоМетода = new СвойстваМетодов();
				СвойствоМетода.ЕстьЗапрос = РекурсивныйПоискЗапроса(Функция.Groups[3].Value, МодульОбъекта, Функция.Index, СвойствоМетода, Функция.Groups[2].Value);
				СвойствоМетода.Index = Функция.Index;
				МодульОбъекта.ДобавитьМетод(Функция.Groups[2].Value, СвойствоМетода);
            }
        }
		#endregion

		public void АнализироватьЦиклы(Модуль МодульОбъекта)
        {

            var ПоискФункций = new Regex(@"(Для|Пока|for|while).+Цикл[\S\s]*?КонецЦикла", RegexOptions.IgnoreCase | RegexOptions.Multiline); //(Для|Пока).+ нужен иначе выражение находит ....Цикла;   код код код для цикл   КонецЦикла;
            //  необходимо переработать это выражение т.к если попадаются вложенные циклы то обрабатываются неверно
            MatchCollection Найдены = ПоискФункций.Matches(МодульОбъекта.Текст);
            foreach (Match Функция in Найдены)
            {
                ТелоКода Тело = new ТелоКода(Функция.Value, МодульОбъекта, Функция.Index);
                if (Тело.ЕстьЗапрос())
                {
                    МодульОбъекта.ДобавитьПроблему(Тело.ПолучитьАнализ());
                    //continue;
                }
				СвойстваМетодов СвойствоМетода = new СвойстваМетодов();
				if(РекурсивныйПоискЗапроса(Функция.Value, МодульОбъекта, Функция.Index, СвойствоМетода, "")){
				СвойствоМетода.Index = Функция.Index;
//				МодульОбъекта.ДобавитьМетод(Функция.Groups[2].Value, СвойствоМетода);
					String СтекСтрокой = СвойствоМетода.ПолучитьСтекСтрокой();
					ИнформацияАнализа Анализ = new ИнформацияАнализа(Функция.Index, СтекСтрокой, СтекСтрокой);
					МодульОбъекта.ДобавитьПроблему(Анализ);

				}

/*				var ПоискВызовов = new Regex(@"^(?!\/\/)[^\.\/]*?([а-яa-z0-9_]*?)[\s]?\(", RegexOptions.IgnoreCase | RegexOptions.Multiline);
				MatchCollection Вызовы = ПоискВызовов.Matches(Функция.Value);
				foreach (Match Вызов in Найдены)
				{

				}
*/

            }

        }

    }
}

