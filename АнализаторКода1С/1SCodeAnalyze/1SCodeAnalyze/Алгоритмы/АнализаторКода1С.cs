using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Text.RegularExpressions;
using System.IO;
using _1SCodeAnalyze.Структуры;

namespace _1SCodeAnalyze
{
    /*
Функция НайденаПроцедураСЗапросом(ТекстБлока, Параметры, ИмяПроцедуры)
    Если ЕстьЗапрос(ТекстБлока, Параметры) Тогда
        Возврат Истина;
    КонецЕсли;
    Параметры.Вложенность = Параметры.Вложенность + 1;
    Если Параметры.Вложенность > 35 Тогда 
        Возврат Ложь; 
    КонецЕсли;//глубина стека вызовов 
    RegExp2 = ИнициализироватьРегулярноеВыражение("");   
    RegExp_ = ИнициализироватьРегулярноеВыражение(@"^(?!\/\/)[^\.\/]*?([а-яa-z0-9_]*?[\s]?\()"); //Поиск вызываемых в цикле методов, необходимо фильтровать закомментированные функции
    Matches = RegExp_.Execute(ТекстБлока);
    ЧислоВхождений = Matches.Count();
    Если ЧислоВхождений = 0 Тогда Возврат Ложь; КонецЕсли;
    Для к = 0 По ЧислоВхождений-1 Цикл
        ОбработкаПрерыванияПользователя();
        Match = Matches.Item(к);
        Value = Match.Submatches.Item(0);//берем лишь название метода с одной скобкой из группировки  без пробелов и точек
        Если Value = ИмяПроцедуры Тогда
        //Рекурсия 	
                Параметры.Косяк = "Рекурсия в функции "+value +")->" + Параметры.Косяк;
                Продолжить;
        КонецЕсли;
		
        Состояние(Value);
        Если ЭтоСистемнаяФункция(Value) Тогда Продолжить; КонецЕсли;
		
        RegExp2.Pattern = @"(Процедур|Функци)[ая][\s]*?" + ЭкранироватьРег(Value) + "([\S\s]*?)Конец\1[ыи]";   // поиск тела найденной в цикле функции во всем тексте модуля
        Matches2 = RegExp2.Execute(Параметры.Текст);
        ЧислоВхождений2 = Matches2.Count();
        Если ЧислоВхождений2 <> 1 Тогда Продолжить; КонецЕсли;
        //сюда попадает тело найденой процедуры
        ТекстПроцедуры = Matches2.Item(0).SubMatches.Item(1); //без названия самой процедуры чтоб не впасть в ложную рекурсию
        Если НайденаПроцедураСЗапросом(ТекстПроцедуры, Параметры, Value) Тогда  //ищем в теле метода запросы или другие методы с запросами .. рекурсивно вызывая саму себя погружаясь все глубже в код
            Параметры.Косяк = value +")->" + Параметры.Косяк + "("+?(Параметры.Вложенность = 1,Строка(НайтиномерСтроки(Параметры,Параметры.Match.FirstIndex + Match.FirstIndex)),"") +")";
            Возврат Истина;
        КонецЕсли;
    КонецЦикла;
    Возврат Ложь;
КонецФункции
@"^(?!\/\/)[^\/]*?\.(выполнить|найтипокоду|найтипореквизиту|найтипонаименованию)[\s]?\(");
Функция _СтрЧислоВхождений(Текст, Подстрока)   //Количество вхождений не закомментированной подстроки 
    RegExp_ = ИнициализироватьРегулярноеВыражение("^(?!\/\/)[^\/]*?[^a-zа-я0-9_]"+ ЭкранироватьРег(Подстрока)+"[^a-zа-я0-9_]");
    Возврат RegExp_.Execute(Текст).Count();
КонецФункции

*/
    //String @"(Процедур|Функци)[ая][\s]*?" + ЭкранироватьРег(Value) + "([\S\s]*?)Конец\1[ыи]"	
    class АнализаторКода1С
    {

        Dictionary<String, Модуль> Модули;
        List<FileInfo> files;

        public АнализаторКода1С(List<FileInfo> files)
        {
            this.files = files;
            Модули = new Dictionary<string, Модуль>();
            ОбойтиВсеФайлы();

        }

        private void ОбойтиВсеФайлы()
        {
            foreach (FileInfo Файл in files)
            {
                String ИмяМодуля = Файл.Name.Replace(".Модуль.txt", "").Replace("ОбщийМодуль.", "").Replace(".txt", "");
                Модуль МодульОбъекта = new Модуль(Файл);
                if (!Модули.ContainsKey(ИмяМодуля))
                {
                    Модули.Add(ИмяМодуля, МодульОбъекта);
                }
            }

            foreach (KeyValuePair<String, Модуль> Объект in Модули) НайтиЦикл(Объект.Value);

        }

        private Boolean ЕстьЗапрос(String Текст, Модуль МодульОбъекта, int Index)
        {
            var ПоискЗапроса = new Regex(@"^(?!\/\/)[^\/]*?\.(выполнить|найтипокоду|найтипореквизиту|найтипонаименованию)[\s]?\(", RegexOptions.IgnoreCase | RegexOptions.Multiline);
            Match Найдены = ПоискЗапроса.Match(Текст);
            if (!Найдены.Success)
                return false;
            МодульОбъекта.ДобавитьПроблему(Найдены.Groups[1].Value, Найдены.Index + Index);
            return true;
        }

        private Boolean РекурсивныйПоискЗапроса(String Текст, Модуль МодульОбъекта, int Index)
        {
            ТелоКода Тело = new ТелоКода(Текст, МодульОбъекта, Index);
            if (Тело.ЕстьЗапрос()) { return true; }
            //Ищем другие вызываемые процедуры
            var ПоискВызовов = new Regex(@"^(?!\/\/)[^\.\/]*?([а-яa-z0-9_]*?)[\s]?\(", RegexOptions.IgnoreCase | RegexOptions.Multiline);
            MatchCollection Найдены = ПоискВызовов.Matches(Текст);
            foreach (Match Вызов in Найдены)
            {
                var ПоискМетода = new Regex(@"(Процедур|Функци|procedur|functio)[аяne][\s]*?" + ЭкранироватьРег(Вызов.Value) + @"[\s]*?\(([\S\s]*?)(Конец|end)\1[ыиen]", RegexOptions.IgnoreCase | RegexOptions.Multiline);
                Match Найден = ПоискМетода.Match(МодульОбъекта.Текст);
                if (!Найден.Success)
                    continue;
                //натравим на эти процедуры эту же функцию
                if(РекурсивныйПоискЗапроса(Найден.Groups[2].Value, МодульОбъекта, Найден.Index))return true;
            }
            return false;
        }
        /// <summary>
        /// Фунция экранирует символы для нормальной подстановки в регулярное выражение
        /// </summary>
        /// <param name="s">Исходная строка</param>
        /// <returns>Результирующая строка</returns>
        private string ЭкранироватьРег(string s)
        {
            string p = s;
            foreach (char c in @"\|.+*(){}^$[]?/".ToCharArray())p = p.Replace("" + c, @"\" + c);
            return p.Replace(" ", @"[\s]*?");
        }


        private void НайтиВсеФункцииИПроцедуры(String ИсходныйКод)
        {
            var ПоискФункций = new Regex(@"^(?!\/\/)[^\.\/]*?(procedur|functio|Процедур|Функци)[enая][\s]*?([А-Яа-яa-z0-9_]*?)[\s]?\([\S\s]*?(Конец|End)\1[enыи]", RegexOptions.IgnoreCase | RegexOptions.Multiline);
            MatchCollection Найдены = ПоискФункций.Matches(ИсходныйКод);
            foreach (Match Функция in Найдены)
            {
                Console.WriteLine("Index={0}, Groups={1}, Captures={2}\n{3}\n{4}", Функция.Index, Функция.Groups.Count, Функция.Captures.Count, Функция.Groups[2].Value, Функция.Groups[3].Value);
            }
        }


        public void НайтиЦикл(Модуль МодульОбъекта)
        {
            var ПоискФункций = new Regex(@"(Для|Пока|for|while).+Цикл[\S\s]*?КонецЦикла", RegexOptions.IgnoreCase | RegexOptions.Multiline); //(Для|Пока).+ нужен иначе выражение находит ....Цикла;   код код код для цикл   КонецЦикла;
            //  необходимо переработать это выражение т.к если попадаются вложенные циклы то обрабатываются неверно
            MatchCollection Найдены = ПоискФункций.Matches(МодульОбъекта.Текст);
            foreach (Match Функция in Найдены)
            {
                ТелоКода Тело = new ТелоКода(Функция.Value, МодульОбъекта, Функция.Index);
                if (Тело.ЕстьЗапрос())
                {
                    МодульОбъекта.ДобавитьПроблему(Тело.ПолучитьАнализ());
                    continue;
                }

                /*
 * Параметры.Смещение = 0;
 			НомерСтроки = "("+Строка(НайтиномерСтроки(Параметры,Match.FirstIndex))+").";
			Если ЕстьЗапрос(Match.Value, Параметры) Тогда
				Параметры.Косяк = "Прямой запрос в цикле "+ НомерСтроки + Параметры.Косяк +"();";
				ДобавитьСтрокуВТаблицу(Параметры);
				Продолжить;
			ИначеЕсли НайденаПроцедураСЗапросом(Match.Value, Параметры, "") Тогда
				Параметры.Косяк =  НомерСтроки + Параметры.Косяк;
				ДобавитьСтрокуВТаблицу(Параметры);
				Продолжить;
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;
     */

            }

        }

    }
}

